# frozen_string_literal: true

module RuboCop
  module Cop
    module Operandi
      # Ensures that symbol conditions in `step` declarations (`:if` and `:unless`)
      # have corresponding methods defined in the same class.
      #
      # This cop automatically recognizes:
      # - Methods defined with `def`
      # - Predicate methods from `arg` and `output` (e.g., `arg :user` creates `user` and `user?`)
      # - Methods from `attr_reader`, `attr_accessor`, and `attr_writer`
      #
      # @example
      #   # bad
      #   class MyService < ApplicationService
      #     step :process, if: :should_process?
      #
      #     private
      #
      #     def process
      #       # should_process? is missing
      #     end
      #   end
      #
      #   # good - explicit method
      #   class MyService < ApplicationService
      #     step :process, if: :should_process?
      #
      #     private
      #
      #     def process; end
      #     def should_process?; true; end
      #   end
      #
      #   # good - predicate from arg
      #   class MyService < ApplicationService
      #     arg :user, type: User, optional: true
      #
      #     step :greet, if: :user?  # user? is auto-generated by arg :user
      #
      #     private
      #
      #     def greet; end
      #   end
      #
      #   # good - attr_reader
      #   class MyService < ApplicationService
      #     attr_reader :enabled
      #
      #     step :process, if: :enabled
      #
      #     private
      #
      #     def process; end
      #   end
      #
      # @example ExcludedMethods: ['admin?', 'guest?'] (default: [])
      #   # good - these methods are excluded from checking
      #   class MyService < ApplicationService
      #     step :admin_action, if: :admin?  # excluded via config
      #   end
      #
      class ConditionMethodExists < Base
        MSG = "Condition method `%<name>s` has no corresponding method. " \
              "For inherited methods, disable this line or add to ExcludedMethods."

        CONDITION_KEYS = [:if, :unless].freeze
        ATTR_METHODS = [:attr_reader, :attr_accessor, :attr_writer].freeze

        def on_class(_node)
          @condition_methods = []
          @defined_methods = []
          @dsl_predicates = []
        end

        def on_send(node)
          if step_call?(node)
            collect_condition_methods(node)
          elsif arg_or_output_call?(node)
            collect_dsl_predicate(node)
          elsif attr_method_call?(node)
            collect_attr_methods(node)
          end
        end

        def on_def(node)
          @defined_methods ||= []
          @defined_methods << node.method_name
        end

        def after_class(_node)
          return unless @condition_methods&.any?

          @condition_methods.each do |condition|
            next if method_available?(condition[:name])
            next if excluded_method?(condition[:name])

            add_offense(condition[:node], message: format(MSG, name: condition[:name]))
          end
        end

        private

        def step_call?(node)
          node.send_type? &&
            node.method_name == :step &&
            node.receiver.nil? &&
            node.arguments.first&.sym_type?
        end

        def arg_or_output_call?(node)
          node.send_type? &&
            [:arg, :output].include?(node.method_name) &&
            node.receiver.nil? &&
            node.arguments.first&.sym_type?
        end

        def attr_method_call?(node)
          node.send_type? &&
            ATTR_METHODS.include?(node.method_name) &&
            node.receiver.nil?
        end

        def collect_condition_methods(node)
          @condition_methods ||= []

          opts_node = node.arguments[1]
          return unless opts_node&.hash_type?

          opts_node.pairs.each do |pair|
            key = pair.key
            value = pair.value

            next unless key.sym_type? && CONDITION_KEYS.include?(key.value)
            next unless value.sym_type?

            @condition_methods << { name: value.value, node: value }
          end
        end

        def collect_dsl_predicate(node)
          @dsl_predicates ||= []

          field_name = node.arguments.first.value
          @dsl_predicates += [field_name, :"#{field_name}?"]
        end

        def collect_attr_methods(node)
          @defined_methods ||= []

          node.arguments.each do |arg|
            next unless arg.sym_type?

            @defined_methods << arg.value
          end
        end

        def method_available?(method_name)
          @defined_methods&.include?(method_name) || @dsl_predicates&.include?(method_name)
        end

        def excluded_method?(method_name)
          excluded_methods.include?(method_name.to_s)
        end

        def excluded_methods
          cop_config.fetch("ExcludedMethods", [])
        end
      end
    end
  end
end
