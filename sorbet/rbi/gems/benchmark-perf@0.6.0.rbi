# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `benchmark-perf` gem.
# Please instead update this file by running `bin/tapioca gem benchmark-perf`.


# source://benchmark-perf//lib/benchmark/perf/clock.rb#4
module Benchmark::Perf
  private

  # Measure execution time(a.k.a cpu time) of a given work
  #
  # @api public
  # @example
  #   Benchmark::Perf.cpu { "foo" + "bar" }
  # @param repeat [Integer] how many times to repeat measurements
  # @param time [Numeric] the time to run measurements in seconds
  # @param warmup [Numeric] the warmup time in seconds
  # @return [Array[Float, Float]]
  #
  # source://benchmark-perf//lib/benchmark/perf.rb#43
  def cpu(**options, &work); end

  # Measure iterations a work could take in a second
  #
  # @api public
  # @example
  #   Benchmark::Perf.ips { "foo" + "bar" }
  # @param time [Numeric] the time to run measurements in seconds
  # @param warmup [Numeric] the warmup time in seconds
  # @return [Array[Integer, Integer, Integer, Float]] the average, standard deviation, iterations and time
  #
  # source://benchmark-perf//lib/benchmark/perf.rb#23
  def ips(**options, &work); end

  class << self
    # Measure execution time(a.k.a cpu time) of a given work
    #
    # @api public
    # @example
    #   Benchmark::Perf.cpu { "foo" + "bar" }
    # @param repeat [Integer] how many times to repeat measurements
    # @param time [Numeric] the time to run measurements in seconds
    # @param warmup [Numeric] the warmup time in seconds
    # @return [Array[Float, Float]]
    #
    # source://benchmark-perf//lib/benchmark/perf.rb#46
    def cpu(**options, &work); end

    # Measure iterations a work could take in a second
    #
    # @api public
    # @example
    #   Benchmark::Perf.ips { "foo" + "bar" }
    # @param time [Numeric] the time to run measurements in seconds
    # @param warmup [Numeric] the warmup time in seconds
    # @return [Array[Integer, Integer, Integer, Float]] the average, standard deviation, iterations and time
    #
    # source://benchmark-perf//lib/benchmark/perf.rb#26
    def ips(**options, &work); end
  end
end

# source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#7
class Benchmark::Perf::CPUResult
  # Create storage for ips results
  #
  # @api private
  # @return [CPUResult] a new instance of CPUResult
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#14
  def initialize; end

  # @api private
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#28
  def <<(time_s); end

  # @api private
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#22
  def add(time_s); end

  # Average ips
  #
  # @api public
  # @return [Integer]
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#35
  def avg; end

  # The time elapsed
  #
  # @api public
  # @return [Float]
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#57
  def dt; end

  # The time elapsed
  #
  # @api public
  # @return [Float]
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#62
  def elapsed_time; end

  # A string representation of this instance
  #
  # @api public
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#73
  def inspect; end

  # The ips standard deviation
  #
  # @api public
  # @return [Integer]
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#46
  def stdev; end

  # @api public
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#65
  def to_a; end

  # @api public
  #
  # source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#68
  def to_ary; end
end

# Indicate no value
#
# source://benchmark-perf//lib/benchmark/perf/cpu_result.rb#9
module Benchmark::Perf::CPUResult::NO_VALUE; end

# Clock that represents monotonic time
#
# source://benchmark-perf//lib/benchmark/perf/clock.rb#6
module Benchmark::Perf::Clock
  private

  # Measure time elapsed with a monotonic clock
  #
  # @return [Float]
  #
  # source://benchmark-perf//lib/benchmark/perf/clock.rb#58
  def measure; end

  # Current monotonic time
  #
  # @api public
  # @return [Float]
  #
  # source://benchmark-perf//lib/benchmark/perf/clock.rb#48
  def now; end

  class << self
    # Measure time elapsed with a monotonic clock
    #
    # @return [Float]
    #
    # source://benchmark-perf//lib/benchmark/perf/clock.rb#64
    def measure; end

    # Current monotonic time
    #
    # @api public
    # @return [Float]
    #
    # source://benchmark-perf//lib/benchmark/perf/clock.rb#51
    def now; end
  end
end

# Microseconds per 100ms
#
# source://benchmark-perf//lib/benchmark/perf/clock.rb#11
Benchmark::Perf::Clock::MICROSECONDS_PER_100MS = T.let(T.unsafe(nil), Integer)

# Microseconds per second
#
# source://benchmark-perf//lib/benchmark/perf/clock.rb#8
Benchmark::Perf::Clock::MICROSECONDS_PER_SECOND = T.let(T.unsafe(nil), Integer)

# source://benchmark-perf//lib/benchmark/perf/clock.rb#40
Benchmark::Perf::Clock::MONOTONIC_CLOCK = T.let(T.unsafe(nil), T.untyped)

# Measure length of time the work could take on average
#
# @api public
#
# source://benchmark-perf//lib/benchmark/perf/execution.rb#11
module Benchmark::Perf::Execution
  private

  # Check if expected value is greater than minimum
  #
  # @api private
  # @param expected [Numeric]
  # @param min [Numeric]
  # @raise [ArgumentError]
  #
  # source://benchmark-perf//lib/benchmark/perf/execution.rb#121
  def check_greater(expected, min); end

  # Perform work x times
  #
  # @api public
  # @example
  #   ExecutionTime.run(repeat: 10) { ... }
  # @param repeat [Integer] how many times to repeat the code measuremenets
  # @return [Array[Float, Float]] average and standard deviation
  #
  # source://benchmark-perf//lib/benchmark/perf/execution.rb#93
  def run(repeat: T.unsafe(nil), io: T.unsafe(nil), warmup: T.unsafe(nil), subprocess: T.unsafe(nil), &work); end

  # Isolate run in subprocess
  #
  # @api private
  # @example
  #   iteration.run_in_subproces { ... }
  # @return [Float] the elapsed time of the measurement
  #
  # source://benchmark-perf//lib/benchmark/perf/execution.rb#29
  def run_in_subprocess(subprocess: T.unsafe(nil), io: T.unsafe(nil)); end

  # Check if measurements need to run in subprocess
  #
  # @api private
  # @return [Boolean]
  #
  # source://benchmark-perf//lib/benchmark/perf/execution.rb#15
  def run_in_subprocess?; end

  # Run warmup measurement
  #
  # @api private
  # @param warmup [Numeric] the warmup time
  #
  # source://benchmark-perf//lib/benchmark/perf/execution.rb#70
  def run_warmup(warmup: T.unsafe(nil), io: T.unsafe(nil), subprocess: T.unsafe(nil), &work); end

  class << self
    # Check if expected value is greater than minimum
    #
    # @api private
    # @param expected [Numeric]
    # @param min [Numeric]
    # @raise [ArgumentError]
    #
    # source://benchmark-perf//lib/benchmark/perf/execution.rb#127
    def check_greater(expected, min); end

    # Perform work x times
    #
    # @api public
    # @example
    #   ExecutionTime.run(repeat: 10) { ... }
    # @param repeat [Integer] how many times to repeat the code measuremenets
    # @return [Array[Float, Float]] average and standard deviation
    #
    # source://benchmark-perf//lib/benchmark/perf/execution.rb#111
    def run(repeat: T.unsafe(nil), io: T.unsafe(nil), warmup: T.unsafe(nil), subprocess: T.unsafe(nil), &work); end

    # Isolate run in subprocess
    #
    # @api private
    # @example
    #   iteration.run_in_subproces { ... }
    # @return [Float] the elapsed time of the measurement
    #
    # source://benchmark-perf//lib/benchmark/perf/execution.rb#62
    def run_in_subprocess(subprocess: T.unsafe(nil), io: T.unsafe(nil)); end

    # Check if measurements need to run in subprocess
    #
    # @api private
    # @return [Boolean]
    #
    # source://benchmark-perf//lib/benchmark/perf/execution.rb#18
    def run_in_subprocess?; end

    # Run warmup measurement
    #
    # @api private
    # @param warmup [Numeric] the warmup time
    #
    # source://benchmark-perf//lib/benchmark/perf/execution.rb#79
    def run_warmup(warmup: T.unsafe(nil), io: T.unsafe(nil), subprocess: T.unsafe(nil), &work); end
  end
end

# source://benchmark-perf//lib/benchmark/perf/ips_result.rb#7
class Benchmark::Perf::IPSResult
  # Create storage for ips results
  #
  # @api private
  # @return [IPSResult] a new instance of IPSResult
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#18
  def initialize; end

  # @api private
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#28
  def add(time_s, cycles_in_100ms); end

  # Average ips
  #
  # @api public
  # @return [Integer]
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#42
  def avg; end

  # The time elapsed
  #
  # @api public
  # @return [Float]
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#64
  def dt; end

  # The time elapsed
  #
  # @api public
  # @return [Float]
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#69
  def elapsed_time; end

  # A string representation of this instance
  #
  # @api public
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#80
  def inspect; end

  # Returns the value of attribute ips.
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#11
  def ips; end

  # Returns the value of attribute iter.
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#13
  def iter; end

  # The ips standard deviation
  #
  # @api public
  # @return [Integer]
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#53
  def stdev; end

  # @api public
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#72
  def to_a; end

  # @api public
  #
  # source://benchmark-perf//lib/benchmark/perf/ips_result.rb#75
  def to_ary; end
end

# Indicate no value
#
# source://benchmark-perf//lib/benchmark/perf/ips_result.rb#9
module Benchmark::Perf::IPSResult::NO_VALUE; end

# Measure number of iterations a work could take in a second
#
# @api private
#
# source://benchmark-perf//lib/benchmark/perf/iteration.rb#12
module Benchmark::Perf::Iteration
  private

  # Call work by given times
  #
  # @api private
  # @param times [Integer] the times to call
  # @return [Integer] the number of times worke has been called
  #
  # source://benchmark-perf//lib/benchmark/perf/iteration.rb#22
  def call_times(times); end

  # Calcualte the number of cycles needed for 100ms
  #
  # @api private
  # @param iterations [Integer]
  # @param time_s [Float] the total time for all iterations in seconds
  # @return [Integer] the cycles per 100ms
  #
  # source://benchmark-perf//lib/benchmark/perf/iteration.rb#41
  def cycles_per_100ms(iterations, time_s); end

  # Run measurements
  #
  # @api public
  # @param time [Numeric] the time to run measurements in seconds
  # @param warmup [Numeric] the warmup time in seconds
  #
  # source://benchmark-perf//lib/benchmark/perf/iteration.rb#80
  def run(time: T.unsafe(nil), warmup: T.unsafe(nil), &work); end

  # Warmup run
  #
  # @api private
  # @param warmup [Numeric] the number of seconds for warmup
  #
  # source://benchmark-perf//lib/benchmark/perf/iteration.rb#55
  def run_warmup(warmup: T.unsafe(nil), &work); end

  class << self
    # Call work by given times
    #
    # @api private
    # @param times [Integer] the times to call
    # @return [Integer] the number of times worke has been called
    #
    # source://benchmark-perf//lib/benchmark/perf/iteration.rb#29
    def call_times(times); end

    # Calcualte the number of cycles needed for 100ms
    #
    # @api private
    # @param iterations [Integer]
    # @param time_s [Float] the total time for all iterations in seconds
    # @return [Integer] the cycles per 100ms
    #
    # source://benchmark-perf//lib/benchmark/perf/iteration.rb#47
    def cycles_per_100ms(iterations, time_s); end

    # Run measurements
    #
    # @api public
    # @param time [Numeric] the time to run measurements in seconds
    # @param warmup [Numeric] the warmup time in seconds
    #
    # source://benchmark-perf//lib/benchmark/perf/iteration.rb#99
    def run(time: T.unsafe(nil), warmup: T.unsafe(nil), &work); end

    # Warmup run
    #
    # @api private
    # @param warmup [Numeric] the number of seconds for warmup
    #
    # source://benchmark-perf//lib/benchmark/perf/iteration.rb#70
    def run_warmup(warmup: T.unsafe(nil), &work); end
  end
end

# source://benchmark-perf//lib/benchmark/perf/stats.rb#5
module Benchmark::Perf::Stats
  private

  # Calculate arithemtic average of measurements
  #
  # @api public
  # @param measurements [Array[Float]]
  # @return [Float] the average of given measurements
  #
  # source://benchmark-perf//lib/benchmark/perf/stats.rb#14
  def average(measurements); end

  # Calculate standard deviation
  #
  # @api public
  # @param measurements [Array[Float]]
  #
  # source://benchmark-perf//lib/benchmark/perf/stats.rb#44
  def stdev(measurements); end

  # Calculate variance of measurements
  #
  # @api public
  # @param measurements [Array[Float]]
  # @return [Float]
  #
  # source://benchmark-perf//lib/benchmark/perf/stats.rb#28
  def variance(measurements); end

  class << self
    # Calculate arithemtic average of measurements
    #
    # @api public
    # @param measurements [Array[Float]]
    # @return [Float] the average of given measurements
    #
    # source://benchmark-perf//lib/benchmark/perf/stats.rb#19
    def average(measurements); end

    # Calculate standard deviation
    #
    # @api public
    # @param measurements [Array[Float]]
    #
    # source://benchmark-perf//lib/benchmark/perf/stats.rb#49
    def stdev(measurements); end

    # Calculate variance of measurements
    #
    # @api public
    # @param measurements [Array[Float]]
    # @return [Float]
    #
    # source://benchmark-perf//lib/benchmark/perf/stats.rb#37
    def variance(measurements); end
  end
end

# source://benchmark-perf//lib/benchmark/perf/version.rb#5
Benchmark::Perf::VERSION = T.let(T.unsafe(nil), String)
