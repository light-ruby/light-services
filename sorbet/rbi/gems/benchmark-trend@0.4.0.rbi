# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `benchmark-trend` gem.
# Please instead update this file by running `bin/tapioca gem benchmark-trend`.


# source://benchmark-trend//lib/benchmark/trend/clock.rb#4
module Benchmark::Trend
  private

  # Check if expected value is greater than minimum
  #
  # @api private
  # @param expected [Numeric]
  # @param min [Numeric]
  # @raise [ArgumentError]
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#55
  def check_greater(expected, min); end

  # Fit the performance measurements to construct a model with
  # slope and intercept parameters that minimize the error.
  #
  # @api public
  # @param xs [Array[Numeric]] the data points along X axis
  # @param ys [Array[Numeric]] the data points along Y axis
  # @return [Array[Numeric, Numeric, Numeric]
  # returns slope, intercept and model's goodness-of-fit] Array[Numeric, Numeric, Numeric]
  #   returns slope, intercept and model's goodness-of-fit
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#180
  def fit(xs, ys, tran_x: T.unsafe(nil), tran_y: T.unsafe(nil)); end

  # Take a fit and estimate behaviour at input size n
  #
  # @api public
  # @example
  #   fit_at(:power, slope: 1.5, intercept: 2, n: 10)
  # @raise [ArgumentError]
  # @return fit model value for input n
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#229
  def fit_at(type, slope: T.unsafe(nil), intercept: T.unsafe(nil), n: T.unsafe(nil)); end

  # Find a line of best fit that approximates exponential function
  #
  # Model form: y = ab^x
  #
  # @api public
  # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#164
  def fit_exp(xs, ys); end

  # Find a line of best fit that approximates exponential function
  #
  # Model form: y = ab^x
  #
  # @api public
  # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#157
  def fit_exponential(xs, ys); end

  # Finds a line of best fit that approximates linear function
  #
  # Function form: y = ax + b
  #
  # @api public
  # @param xs [Array[Numeric]] the data points along X axis
  # @param ys [Array[Numeric]] the data points along Y axis
  # @return [Numeric, Numeric, Numeric] return a slope, b intercept and rr correlation coefficient
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#106
  def fit_linear(xs, ys); end

  # Find a line of best fit that approximates logarithmic function
  #
  # Model form: y = a*lnx + b
  #
  # @api public
  # @param xs [Array[Numeric]] the data points along X axis
  # @param ys [Array[Numeric]] the data points along Y axis
  # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#130
  def fit_log(xs, ys); end

  # Find a line of best fit that approximates logarithmic function
  #
  # Model form: y = a*lnx + b
  #
  # @api public
  # @param xs [Array[Numeric]] the data points along X axis
  # @param ys [Array[Numeric]] the data points along Y axis
  # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#125
  def fit_logarithmic(xs, ys); end

  # Finds a line of best fit that approxmimates power function
  #
  # Function form: y = bx^a
  #
  # @api public
  # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#141
  def fit_power(xs, ys); end

  # A mathematical notation template for a trend type
  #
  # @api private
  # @param type [String] the fit model type
  # @return [String] the formatted mathematical function template
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#256
  def format_fit(type); end

  # Infer trend from the execution times
  #
  # Fits the executiom times for each range to several fit models.
  #
  # @api public
  # @param repeat [Integer] nubmer of times work is called to compute execution time
  # @return [Array[Symbol, Hash]] the best fitting and all the trends
  # @yieldparam work the block of which the complexity is measured
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#289
  def infer_trend(data, repeat: T.unsafe(nil), &work); end

  # Gather times for each input against an algorithm
  #
  # @api public
  # @param data [Array[Numeric]] the data to run measurements for
  # @param repeat [Integer] nubmer of times work is called to compute execution time
  # @return [Array[Array, Array]]
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#74
  def measure_execution_time(data = T.unsafe(nil), repeat: T.unsafe(nil), &work); end

  # Generate a range of inputs spaced by powers.
  #
  # The default range is generated in the multiples of 8.
  #
  # @api public
  # @example
  #   Benchmark::Trend.range(8, 8 << 10)
  #   # => [8, 64, 512, 4096, 8192]
  # @param limit [Integer]
  # @param ratio [Integer]
  # @param start [Integer]
  #
  # source://benchmark-trend//lib/benchmark/trend.rb#29
  def range(start, limit, ratio: T.unsafe(nil)); end

  class << self
    # Fit the performance measurements to construct a model with
    # slope and intercept parameters that minimize the error.
    # returns slope, intercept and model's goodness-of-fit] Array[Numeric, Numeric, Numeric]
    #   returns slope, intercept and model's goodness-of-fit
    #
    # @api public
    # @param xs [Array[Numeric]] the data points along X axis
    # @param ys [Array[Numeric]] the data points along Y axis
    # @return [Array[Numeric, Numeric, Numeric]] Array[Numeric, Numeric, Numeric]
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#218
    def fit(xs, ys, tran_x: T.unsafe(nil), tran_y: T.unsafe(nil)); end

    # Take a fit and estimate behaviour at input size n
    #
    # @api public
    # @example
    #   fit_at(:power, slope: 1.5, intercept: 2, n: 10)
    # @raise [ArgumentError]
    # @return fit model value for input n
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#245
    def fit_at(type, slope: T.unsafe(nil), intercept: T.unsafe(nil), n: T.unsafe(nil)); end

    # Find a line of best fit that approximates exponential function
    #
    # Model form: y = ab^x
    #
    # @api public
    # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#165
    def fit_exp(xs, ys); end

    # Find a line of best fit that approximates exponential function
    #
    # Model form: y = ab^x
    #
    # @api public
    # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#162
    def fit_exponential(xs, ys); end

    # Finds a line of best fit that approximates linear function
    #
    # Function form: y = ax + b
    #
    # @api public
    # @param xs [Array[Numeric]] the data points along X axis
    # @param ys [Array[Numeric]] the data points along Y axis
    # @return [Numeric, Numeric, Numeric] return a slope, b intercept and rr correlation coefficient
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#109
    def fit_linear(xs, ys); end

    # Find a line of best fit that approximates logarithmic function
    #
    # Model form: y = a*lnx + b
    #
    # @api public
    # @param xs [Array[Numeric]] the data points along X axis
    # @param ys [Array[Numeric]] the data points along Y axis
    # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#131
    def fit_log(xs, ys); end

    # Find a line of best fit that approximates logarithmic function
    #
    # Model form: y = a*lnx + b
    #
    # @api public
    # @param xs [Array[Numeric]] the data points along X axis
    # @param ys [Array[Numeric]] the data points along Y axis
    # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#128
    def fit_logarithmic(xs, ys); end

    # Finds a line of best fit that approxmimates power function
    #
    # Function form: y = bx^a
    #
    # @api public
    # @return [Numeric, Numeric, Numeric] returns a, b, and rr values
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#147
    def fit_power(xs, ys); end

    # A mathematical notation template for a trend type
    #
    # @api private
    # @param type [String] the fit model type
    # @return [String] the formatted mathematical function template
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#270
    def format_fit(type); end

    # Infer trend from the execution times
    #
    # Fits the executiom times for each range to several fit models.
    #
    # @api public
    # @param repeat [Integer] nubmer of times work is called to compute execution time
    # @return [Array[Symbol, Hash]] the best fitting and all the trends
    # @yieldparam work the block of which the complexity is measured
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#316
    def infer_trend(data, repeat: T.unsafe(nil), &work); end

    # Gather times for each input against an algorithm
    #
    # @api public
    # @param data [Array[Numeric]] the data to run measurements for
    # @param repeat [Integer] nubmer of times work is called to compute execution time
    # @return [Array[Array, Array]]
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#90
    def measure_execution_time(data = T.unsafe(nil), repeat: T.unsafe(nil), &work); end

    # Change module function visiblity to private
    #
    # @api private
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#11
    def private_module_function(method); end

    # Generate a range of inputs spaced by powers.
    #
    # The default range is generated in the multiples of 8.
    #
    # @api public
    # @example
    #   Benchmark::Trend.range(8, 8 << 10)
    #   # => [8, 64, 512, 4096, 8192]
    # @param limit [Integer]
    # @param ratio [Integer]
    # @param start [Integer]
    #
    # source://benchmark-trend//lib/benchmark/trend.rb#45
    def range(start, limit, ratio: T.unsafe(nil)); end

    private

    # source://benchmark-trend//lib/benchmark/trend.rb#12
    def check_greater(expected, min); end
  end
end

# Clock that represents monotonic time
#
# source://benchmark-trend//lib/benchmark/trend/clock.rb#6
module Benchmark::Trend::Clock
  private

  # Measure time elapsed with a monotonic clock
  #
  # @return [Float]
  #
  # source://benchmark-trend//lib/benchmark/trend/clock.rb#58
  def measure; end

  # Current monotonic time
  #
  # @api public
  # @return [Float]
  #
  # source://benchmark-trend//lib/benchmark/trend/clock.rb#48
  def now; end

  class << self
    # Measure time elapsed with a monotonic clock
    #
    # @return [Float]
    #
    # source://benchmark-trend//lib/benchmark/trend/clock.rb#64
    def measure; end

    # Current monotonic time
    #
    # @api public
    # @return [Float]
    #
    # source://benchmark-trend//lib/benchmark/trend/clock.rb#51
    def now; end
  end
end

# Microseconds per 100ms
#
# source://benchmark-trend//lib/benchmark/trend/clock.rb#11
Benchmark::Trend::Clock::MICROSECONDS_PER_100MS = T.let(T.unsafe(nil), Integer)

# Microseconds per second
#
# source://benchmark-trend//lib/benchmark/trend/clock.rb#8
Benchmark::Trend::Clock::MICROSECONDS_PER_SECOND = T.let(T.unsafe(nil), Integer)

# source://benchmark-trend//lib/benchmark/trend/clock.rb#40
Benchmark::Trend::Clock::MONOTONIC_CLOCK = T.let(T.unsafe(nil), T.untyped)

# the trends to consider
#
# source://benchmark-trend//lib/benchmark/trend.rb#273
Benchmark::Trend::FIT_TYPES = T.let(T.unsafe(nil), Array)

# source://benchmark-trend//lib/benchmark/trend/version.rb#5
Benchmark::Trend::VERSION = T.let(T.unsafe(nil), String)
