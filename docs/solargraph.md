# Solargraph Integration

Light Services provides a Solargraph plugin that enhances your editor experience by informing the language server about methods generated by the `arg` and `output` DSL keywords.

## Features

When you use the `arg` or `output` keywords, Light Services dynamically generates methods at runtime:

```ruby
class MyService < ApplicationService
  arg :user, type: User
  output :result, type: Hash
end
```

This generates the following methods:
- `user` - getter method (returns `User`)
- `user?` - predicate method (returns boolean)
- `user=` - setter method (private, accepts `User`)
- `result` - getter method (returns `Hash`)
- `result?` - predicate method (returns boolean)
- `result=` - setter method (private, accepts `Hash`)

The Solargraph plugin teaches the language server about these generated methods, enabling:

- **Completion** - Autocomplete generated method names
- **Hover** - See information about generated methods, including return types
- **Signature Help** - Get parameter hints for setter methods

## Setup

### 1. Add the Plugin to Your `.solargraph.yml`

```yaml
plugins:
  - solargraph-light-services
```

### 2. Require the Plugin

In your project, ensure the plugin is loaded. You can do this by adding a require in a file that Solargraph processes:

```ruby
# In a file like config/initializers/solargraph.rb or similar
require "solargraph/light_services"
```

Alternatively, if you have a `.solargraph.yml` with a `require` section:

```yaml
require:
  - solargraph/light_services
```

### Requirements

- Solargraph `~> 0.50` or later
- Light Services gem installed in your project

### Verification

To verify the plugin is loaded, run:

```bash
solargraph scan
```

You should see your service files being processed with the generated methods recognized.

## How It Works

The plugin uses Solargraph's **Convention** system to generate virtual method pins during code analysis. When the convention encounters an `arg` or `output` call with a symbol argument, it automatically creates three method pins (getter, predicate, setter) with YARD documentation.

This is a static analysis approach - the plugin analyzes your source code without executing it. This means:

- Methods are recognized immediately as you type
- No running application is required
- Works with any editor that supports Solargraph (VS Code, Vim, Emacs, etc.)

## Type Inference

The plugin extracts type information from the `type:` option and includes it as YARD-style documentation comments. This enables hover information to display return types for generated methods.

### Simple Ruby Types

```ruby
arg :user, type: User      # → @return [User]
arg :items, type: Array    # → @return [Array]
arg :name, type: String    # → @return [String]
```

### Namespaced Types

```ruby
arg :payment, type: Stripe::Charge      # → @return [Stripe::Charge]
arg :config, type: MyApp::Configuration # → @return [MyApp::Configuration]
```

### Dry-Types

Common dry-types are mapped to their underlying Ruby types:

| Dry-Type | Ruby Type |
|----------|-----------|
| `Types::String`, `Types::Strict::String`, `Types::Coercible::String` | `String` |
| `Types::Integer`, `Types::Strict::Integer`, `Types::Coercible::Integer` | `Integer` |
| `Types::Float`, `Types::Strict::Float`, `Types::Coercible::Float` | `Float` |
| `Types::Bool`, `Types::Strict::Bool` | `Boolean` |
| `Types::Array`, `Types::Strict::Array` | `Array` |
| `Types::Hash`, `Types::Strict::Hash` | `Hash` |
| `Types::Symbol`, `Types::Strict::Symbol` | `Symbol` |
| `Types::Date`, `Types::DateTime`, `Types::Time` | `Date`, `DateTime`, `Time` |

Constrained and parameterized types extract their base type:

```ruby
arg :email, type: Types::String.constrained(format: /@/)  # → String
arg :tags, type: Types::Array.of(Types::String)           # → Array
arg :status, type: Types::String.enum("active", "pending") # → String
```

### Custom Type Mappings

You can add custom type mappings through the Light Services configuration:

```ruby
# config/initializers/light_services.rb
Light::Services.configure do |config|
  config.solargraph_type_mappings = {
    "Types::UUID" => "String",
    "Types::Money" => "BigDecimal",
    "Types::JSON" => "Hash",
    "CustomTypes::Email" => "String",
    "MyApp::Types::PhoneNumber" => "String",
  }
end
```

Custom mappings take precedence over the default dry-types mappings, allowing you to:

- Add mappings for your own custom types
- Override default mappings if needed
- Support domain-specific type modules

## Limitations

- Only `arg` and `output` declarations with a symbol as the first argument are recognized
- The plugin cannot detect dynamically computed argument names (e.g., `arg some_variable`)
- Inherited arguments/outputs from parent classes are not automatically discovered
- Parameterized dry-types like `Types::Array.of(Types::String)` resolve to the container type (`Array`), not the full generic type
- Custom dry-type definitions outside the standard `Types::` namespace require explicit mapping
- Go-to-definition for step symbols is not yet supported (use Ruby LSP for this feature)

## Comparison with Ruby LSP

| Feature | Ruby LSP | Solargraph |
|---------|----------|------------|
| Auto-discovery | ✅ Automatic | Requires config |
| Go-to-definition | ✅ Full support | Limited |
| Completion | ✅ | ✅ |
| Hover with types | ✅ | ✅ |
| Step navigation | ✅ | ❌ |

If your editor supports both Ruby LSP and Solargraph, we recommend using the Ruby LSP integration for the best experience with Light Services.

## What's Next?

Learn more about other integrations:

- [Ruby LSP Integration](ruby-lsp.md) - Alternative LSP integration with more features
- [RuboCop Integration](rubocop.md) - Static analysis cops for services
- [Testing](testing.md) - Testing your services with RSpec matchers





